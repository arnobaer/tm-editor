#!/usr/bin/env python2
# -*- coding: utf-8 -*-

from PyQt4.QtCore import *
from PyQt4.QtGui import *

from collections import namedtuple
import time
import random, math
import argparse
import sys, os

import tmGrammar
from tmEditor import Menu
from tmEditor.Menu import toObject
from tmEditor import Toolbox

"""Draft GUI to generate random menus for VHDL synthesis tests.

class MenuGenerator, reads scales fom exisitng XML menu, generates a new random menu.
class GeneratorWidget, input mask for generator
class MainWindow, main window with tab widget holding generator masks

"""

MaxAlgorithms = 512

# Used for storing settings and retrieving actual generator setup.
CutSpec = namedtuple('CutSpec', 'name count')
ObjectSpec = namedtuple('ObjectSpec', 'name cuts')
FunctionSpec = namedtuple('FunctionSpec', 'name cuts objects')
GeneratorSpec = namedtuple('GeneratorSpec', 'count function multiplicator')

class Settings:
    # Object cuts
    ETA = CutSpec(tmGrammar.ETA, count=2)
    PHI = CutSpec(tmGrammar.PHI, count=2)
    ISO = CutSpec(tmGrammar.ISO, count=1)
    QLTY = CutSpec(tmGrammar.QLTY, count=1)

    # Function cuts
    DETA = CutSpec(tmGrammar.DETA, count=2)
    DPHI = CutSpec(tmGrammar.DPHI, count=2)
    DR = CutSpec(tmGrammar.DR, count=2)
    MASS = CutSpec(tmGrammar.MASS, count=2)
    CHGCOR = CutSpec(tmGrammar.CHGCOR, count=1)

    # Objects
    MU = ObjectSpec(tmGrammar.MU, cuts=[ETA, PHI, ISO, QLTY])
    EG = ObjectSpec(tmGrammar.EG, cuts=[ETA, PHI])
    JET = ObjectSpec(tmGrammar.JET, cuts=[ETA, PHI])
    TAU = ObjectSpec(tmGrammar.TAU, cuts=[ETA, PHI])
    ETM = ObjectSpec(tmGrammar.ETM, cuts=[PHI])
    HTM = ObjectSpec(tmGrammar.HTM, cuts=[PHI])
    ETT = ObjectSpec(tmGrammar.ETT, cuts=[])
    HTT = ObjectSpec(tmGrammar.HTT, cuts=[])

    # All objects
    Objects = (MU, EG, JET, TAU, ETM, HTM, ETT, HTT)

    # Functions
    Functions = (
        FunctionSpec("Single", [], [MU, EG, JET, TAU, ETM, HTM, ETT, HTT]),
        FunctionSpec("Double", [CHGCOR], [MU, EG, JET, TAU]),
        FunctionSpec("Triple", [], [MU, EG, JET, TAU]),
        FunctionSpec("Quad", [], [MU, EG, JET, TAU]),
        FunctionSpec("Dist", [DETA, DPHI], [MU, EG, JET, TAU, ETM, HTM]), # etm, htm will be handled separately
        FunctionSpec("DR", [DR], [MU, EG, JET, TAU]),
        FunctionSpec("Mass", [MASS], [MU, EG, JET, TAU]),
    )

class MenuGenerator(Menu):

    def __init__(self, filename):
        super(MenuGenerator, self).__init__(filename)
        self.reset() # clear contents

    def reset(self):
        self.menu['name'] = ("L1Menu_Autogen_%s" % time.time()).split('.')[0]
        self.menu['comment'] = "Auto generated menu by Trigger Menu Wizard"
        self.menu['is_valid'] = "1"
        self.algorithms = []
        self.cuts = []
        self.objects = []
        self.externals = []

    def randomEtThreshold(self, type):
        value = float(random.choice(self.scales.bins["%s-ET" % type])['minimum'])
        return str(value).replace('.', 'p') # float to threshold

    def addRandomObjectCut(self, objectSpec):
        cuts = []
        for type, count in objectSpec.cuts:
            for i in range(random.randint(1, count)):
                minimum, maximum, data = '', '', ''
                key = "{objectSpec.name}-{type}".format(**locals())
                if type == tmGrammar.ETA:
                    minimum, maximum = sorted([
                        random.choice(self.scales.bins[key])['minimum'],
                        random.choice(self.scales.bins[key])['maximum'],
                    ])
                elif type == tmGrammar.PHI:
                    minimum, maximum = sorted([
                        random.choice(self.scales.bins[key])['minimum'],
                        random.choice(self.scales.bins[key])['maximum'],
                    ])
                elif type == tmGrammar.ISO:
                    data = str(random.choice(range(2)))
                elif type == tmGrammar.QLTY:
                    data = str(random.choice(range(16)))
                else:
                    continue # TODO
                suffix = str(len(self.cuts) + len(cuts)) # simple enumeration
                name = "{key}_{suffix}".format(**locals())
                self.addCut(name, type=type, object=objectSpec.name, minimum=minimum, maximum=maximum, data=data)
                cuts.append(name)
        return ','.join(cuts)

    def addRandomFunctionCut(self, funcSpec):
        cuts = []
        for type, count in funcSpec.cuts:
            for i in range(random.randint(1, count)):
                object_, minimum, maximum, data = '', '', '', ''
                if type == tmGrammar.CHGCOR:
                    object_ = tmGrammar.comb
                    data = str(random.choice(range(2)))
                elif type == tmGrammar.DETA:
                    object_ = tmGrammar.dist
                    minimum, maximum = sorted([
                        random.randrange(0, 4000) / 1000.,
                        random.randrange(0, 4000) / 1000.,
                    ])
                elif type == tmGrammar.DPHI:
                    object_ = tmGrammar.dist
                    minimum, maximum = sorted([
                        random.randrange(0, int(math.pi/2*1000)) / 1000.,
                        random.randrange(0, int(math.pi/2*1000)) / 1000.,
                    ])
                elif type == tmGrammar.DR:
                    object_ = tmGrammar.dist
                    minimum, maximum = sorted([
                        random.randrange(0, 10000, 1) / 10.,
                        random.randrange(0, 10000, 1) / 10.,
                    ])
                elif type == tmGrammar.MASS:
                    object_ = tmGrammar.mass
                    minimum, maximum = sorted([
                        random.randrange(0, 10000, 2) / 10.,
                        random.randrange(0, 10000, 2) / 10.,
                    ])
                else:
                    continue # TODO
                suffix = str(len(self.cuts) + len(cuts)) # simple enumeration
                name = "{type}_{suffix}".format(**locals())
                self.addCut(name, type=type, object=object_, minimum=minimum, maximum=maximum, data=data)
                cuts.append(name)
        return ','.join(cuts)

    def addRandomObject(self, objectSpecs):
        objectSpec = random.choice(objectSpecs)
        type = objectSpec.name
        threshold = self.randomEtThreshold(type)
        bx_offset = ['-2', '-1', '', '+1', '+2'][2] # TODO
        name = "{type}{threshold}{bx_offset}".format(**locals())
        self.addObject(name, type, threshold)
        cutList = self.addRandomObjectCut(objectSpec)
        if cutList:
            return "{name}[{cutList}]".format(**locals())
        return name

    def addRandomObjects(self, objectSpecs, count, mixedTypes=False):
        if not mixedTypes: # pick one out
            objectSpecs = [random.choice(objectSpecs)]
        objects = [self.addRandomObject(objectSpecs) for i in range(count)]
        alphabet=['MU', 'EG', 'TAU', 'JET', 'ETM', 'HTM', 'ETT', 'HTT'] # qick and dirty sort, muons must be first in arg list
        objects = sorted(objects, key=lambda value: alphabet.index(toObject(value).type))
        return ','.join(objects)

    def generate(self, data):
        print data
        for i in range(data.count):
            expression = []
            for j in range(data.multiplicator):
                if j > 0:
                    expression.append(random.choice([tmGrammar.AND, tmGrammar.OR, tmGrammar.XOR]))
                if data.function.name == "Single":
                    expression.append(self.addRandomObject(data.function.objects))
                elif data.function.name  == "Double":
                    objectList = self.addRandomObjects(data.function.objects, 2, mixedTypes=False)
                    expression.append("comb{{{objectList}}}".format(**locals()))
                elif data.function.name == "Triple":
                    objectList = self.addRandomObjects(data.function.objects, 3, mixedTypes=False)
                    expression.append("comb{{{objectList}}}".format(**locals()))
                elif data.function.name == "Quad":
                    objectList = self.addRandomObjects(data.function.objects, 4, mixedTypes=False)
                    expression.append("comb{{{objectList}}}".format(**locals()))
                elif data.function.name in ("Dist", "DR"):
                    objectList = self.addRandomObjects(data.function.objects, 2, mixedTypes=True)
                    distCutList = self.addRandomFunctionCut(data.function)
                    expression.append("dist{{{objectList}}}[{distCutList}]".format(**locals()))
                elif data.function.name == "Mass":
                    objectList = self.addRandomObjects(data.function.objects, 2, mixedTypes=True)
                    massCutList = self.addRandomFunctionCut(data.function)
                    expression.append("mass{{{objectList}}}[{massCutList}]".format(**locals()))
            index = len(self.algorithms)
            algorithm = dict(
                index=index,
                name="L1_Autogen_{index}".format(**locals()),
                expression=' '.join(expression)
            )
            print "adding algorithm", algorithm
            self.addAlgorithm(**algorithm)

class GeneratorWidget(QWidget):
    """Generator tab page widget."""
    def __init__(self, parent = None):
        super(GeneratorWidget, self).__init__(parent)
        # Count
        self.countSpinBox = QSpinBox(self)
        self.countSpinBox.setRange(0, MaxAlgorithms)
        # Function
        self.functionComboBox = QComboBox(self)
        # Multiplicator
        self.multiSpinBox = QSpinBox(self)
        self.multiSpinBox.setRange(1, 16)
        # Function cuts
        self.functionCuts = []
        for function in Settings.Functions:
            self.functionComboBox.addItem(function.name, function)
            for cut in function.cuts:
                box = QSpinBox(self)
                minimum = 1 if cut.name in (tmGrammar.DR, tmGrammar.MASS) else 0
                box.setRange(minimum, cut.count)
                box.setSuffix(self.tr("x %1").arg(cut.name))
                box.userData = cut
                self.functionCuts.append(box)
        self.objects = []
        self.objectCuts = {}
        for object_ in Settings.Objects:
            box = QCheckBox(self.tr(object_.name), self)
            box.userData = object_
            self.objects.append(box)
            self.objectCuts[object_.name] = []
            for cut in object_.cuts:
                box = QSpinBox(self)
                box.setRange(0, cut.count)
                box.setSuffix(self.tr("x %1").arg(cut.name))
                box.userData = cut
                self.objectCuts[object_.name].append(box)
        # Layout
        layout = QGridLayout()
        layout.addWidget(QLabel(self.tr("Count"), self), 0, 0)
        layout.addWidget(self.countSpinBox, 0, 1)
        layout.addItem(QSpacerItem(0, 0, QSizePolicy.Expanding, QSizePolicy.Minimum), 0, 16)
        layout.addWidget(QLabel(self.tr("Function"), self), 1, 0)
        layout.addWidget(self.functionComboBox, 1, 1)
        layout.addWidget(QLabel(self.tr("Multiplicator"), self), 2, 0)
        layout.addWidget(self.multiSpinBox, 2, 1)
        layout.addWidget(QLabel(self.tr("Function Cuts"), self), 3, 0)
        for i, cut in enumerate(self.functionCuts):
            layout.addWidget(cut, 3, i + 1)
        layout.addWidget(QLabel(self.tr("Objects/Cuts"), self), 4, 0)
        for i, object_ in enumerate(self.objects):
            layout.addWidget(object_, 4 + i, 1)
            for j, cut in enumerate(self.objectCuts[object_.userData.name]):
                layout.addWidget(cut, 4 + i, 2 + j)
        layout.addItem(QSpacerItem(0, 0, QSizePolicy.Minimum, QSizePolicy.Expanding), 16, 0)
        self.setLayout(layout)
        # Setup slots
        self.countSpinBox.valueChanged.connect(self.countChanged)
        self.functionComboBox.currentIndexChanged.connect(self.functionChanged)
        # Call slots
        self.countChanged(self.countSpinBox.value()) # disable initial generator

    def countChanged(self, value):
        """Enables widgets if count greater then zero, else disables them."""
        self.functionComboBox.setEnabled(value)
        for widget in self.functionCuts:
            widget.setEnabled(value)
        self.multiSpinBox.setEnabled(value)
        for widget in self.objects:
            widget.setEnabled(value)
            for widget in self.objectCuts[widget.userData.name]:
                widget.setEnabled(value)
        self.functionChanged(self.functionComboBox.currentIndex())

    def functionChanged(self, index):
        """Enables or disabled widgets by function attributes."""
        function = self.functionComboBox.itemData(index).toPyObject()
        for widget in self.functionCuts:
            widget.setEnabled(widget.userData in function.cuts)
        for widget in self.objects:
            widget.setEnabled(widget.userData in function.objects)
            for widget2 in self.objectCuts[widget.userData.name]:
                widget2.setEnabled(widget.isEnabled())

    def getFunctionCuts(self):
        return [CutSpec(widget.userData.name, widget.value()) for widget in self.functionCuts if widget.isEnabled() and widget.value()]

    def getObjectCuts(self, objectname):
        return [CutSpec(widget.userData.name, widget.value()) for widget in self.objectCuts[objectname] if widget.isEnabled() and widget.value()]

    def getObjects(self):
        return [ObjectSpec(widget.userData.name, self.getObjectCuts(widget.userData.name)) for widget in self.objects if widget.isEnabled() and widget.isChecked()]

    def data(self):
        """Return current generator setup."""
        count = self.countSpinBox.value()
        multiplicator = self.multiSpinBox.value()
        functionCuts = self.getFunctionCuts()
        objects = self.getObjects()
        name = self.functionComboBox.itemData(self.functionComboBox.currentIndex()).toPyObject().name
        function = FunctionSpec(name, functionCuts, objects)
        return GeneratorSpec(count, function, multiplicator)

class MainWindow(QWidget):

    def __init__(self, parent = None):
        super(MainWindow, self).__init__(parent)
        self.setWindowTitle(self.tr("Trigger Menu Wizard"))
        self.resize(640, 480)
        # Setup tab widget
        self.tabWidget = QTabWidget(self)
        self.tabWidget.setDocumentMode(True)
        self.tabWidget.setTabsClosable(True)
        self.tabWidget.tabCloseRequested.connect(self.tabWidget.removeTab)
        self.tabWidget.tabCounter = 1
        self.addButton = QPushButton(self.tr("+"), self)
        self.addButton.setStyleSheet("font: 23px bolder; min-width: 28px; max-width: 28px; margin: 0px;")
        self.addButton.clicked.connect(self.addGeneratorTab)
        self.tabWidget.setCornerWidget(self.addButton)
        # Setup introduction text area
        self.textEdit = QTextEdit(self)
        self.textEdit.setReadOnly(True)
        self.textEdit.setText(QString(
            "<h1>Trigger Menu Wizard</h1>"
            "<p>Generating randomized trigger menus for software and firmware validation.</p>"
            "<p>Use as many generators as required to create different sets of algorithms.</p>"
            "<h2>Quick Guide</h2>"
            "<p>Click <strong>Load XML...</strong> to load an existing XML menu to retrieve a scale set for the new menu to be generated.</p>"
            "<p>Setup generators as required. Add new generators with the add button on the top right.</p>"
            "<p>Click <strong>Generate XML...</strong> to select a location and filename for the generated menu.</p>"
            "<h2>About Generators</h2>"
            "<p><strong>Count</strong> defines the number of algorithms are generated by a generator. "
            "However take note that the sum of all generator counts can not exceed the maximum allowed "
            "algorithm count of %1</p>"
            "<p><strong>Multiplicator</strong> will duplicate each statement with AND's and OR's. "
            "It can be used for generating cross conditions like <pre>MU10 AND JET10</pre></p>"
            "<p>Function cuts allow to define how many of cuts are applied to a function</p>"
        ).arg(MaxAlgorithms))
        index = self.tabWidget.addTab(self.textEdit, self.tr("Introduction")) # add introduction tab
        self.tabWidget.tabBar().setTabButton(0, QTabBar.RightSide, None) # remove tab close button.
        self.addGeneratorTab() # add initial generator tab
        self.tabWidget.setCurrentIndex(index) # raise introduction tab
        self.loadButton = QPushButton(self.tr("&Load XML..."), self)
        self.loadButton.clicked.connect(self.loadXml)
        self.generateButton = QPushButton(self.tr("&Generate XML..."), self)
        self.generateButton.clicked.connect(self.generateXml)
        self.generateButton.setEnabled(False)
        self.quitButton = QPushButton(self.tr("&Quit"), self)
        self.quitButton.clicked.connect(self.close)
        # Setup layouts
        vbox = QVBoxLayout()
        vbox.setContentsMargins(0, 0, 0, 0)
        vbox.addWidget(self.tabWidget)
        hbox = QHBoxLayout()
        hbox.setContentsMargins(5, 0, 5, 5)
        hbox.addWidget(self.loadButton)
        hbox.addWidget(QLabel(self.tr("Load scales from XML menu"), self))
        hbox.addItem(QSpacerItem(0, 0, QSizePolicy.Expanding, QSizePolicy.Minimum))
        hbox.addWidget(self.generateButton)
        hbox.addWidget(self.quitButton)
        vbox.addLayout(hbox)
        self.setLayout(vbox)

    def addGeneratorTab(self):
        """Add new generator page."""
        widget = GeneratorWidget(self)
        text = self.tr("Generator %1").arg(self.tabWidget.tabCounter)
        index = self.tabWidget.addTab(widget, text)
        self.tabWidget.tabCounter += 1
        self.tabWidget.setCurrentIndex(index)

    def loadXml(self, filename = None):
        if not filename:
            filename = QFileDialog.getOpenFileName(self, self.tr("Open XML Menu"),
                QDir.currentPath(), self.tr("XML files (*.xml)"))
        if not filename:
            return
        try:
            self.generator = MenuGenerator(str(filename))
        except Exception, e:
            message = QErrorMessage(self)
            message.showMessage(str(e))
            raise
        self.generateButton.setEnabled(True)

    def generateXml(self, filename = None):
        if not filename:
            filename = QFileDialog.getSaveFileName(self, self.tr("Save XML Menu"),
                QDir.currentPath(), self.tr("XML files (*.xml)"))
        if not filename:
            return
        try:
            self.generator.reset() # Make sure to reset generated contents, else acculmulates
            for i in range(self.tabWidget.count()):
                widget = self.tabWidget.widget(i)
                if isinstance(widget, GeneratorWidget):
                    self.generator.generate(widget.data())
            self.generator.writeXml(str(filename))
            self.generator.reset() # Make sure to reset generated contents, else acculmulates
        except Exception, e:
            message = QErrorMessage(self)
            message.showMessage(str(e))
            raise

def main():
    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('filename', default=None, help="load scales from XML menu")
    args = parser.parse_args()
    # Create application
    app = QApplication(sys.argv)
    window = MainWindow()
    if args.filename:
        window.loadXml(args.filename)
    window.show()
    return app.exec_()

if __name__ == '__main__':
    sys.exit(main())
